/*
	Comp2659 Asg#2 Phase 1

	Donovan Paget
	Ryan Wright

*/

#include "model.h"
#include <stdio.h>
#include <math.h>
#include <osbind.h>
#include "bitmap.h"


#define SCREEN_WIDTH 640
#define SCREEN_HEIGHT 400





struct city destroy_City(struct city);
struct missile_Silo update_Ammo(struct missile_Silo);
struct missile_Silo destroy_Silo(struct missile_Silo);
struct missile missile_Fired(unsigned int, unsigned int, struct missile);
struct missile missile_Destroyed(struct missile);
struct missile enemy_Missile_Fired();
struct missile friendly_Missile_Fired(unsigned int, unsigned int);
struct missile missile_Movement(unsigned int nextX, unsigned int nextY, struct missile Shot);


void create_Explosion(unsigned int coordX,unsigned int coordY);
void plot_pixel(char *base, int x, int y);
void draw_Line(char *base,unsigned int startX,unsigned int startY, unsigned int endX,unsigned int endY);
void plot_bitmap(long int *base, unsigned int x, unsigned int y, long int map[], int numLines);
void clear_bitmap(long int *base, unsigned int x, unsigned int y, long int map[]);

int choose_silo(unsigned int);

void test_Driver();


int main()
{

	/*frame buffer*/
	char *base;	
	long int *iBase;
	

	/*Code for the current state of the game the inital state*/
	int p1_Score = 0;

	/*The silo position*/
	struct missile_Silo left_Silo = {10,1,40,350};
	struct missile_Silo middle_Silo = {10,1,300,350};
	struct missile_Silo right_Silo = {10,1,560,350};

	/*city position*/
	struct city city1 = {1,120,350};
	struct city city2 = {1,200,350};
	struct city city3 = {1,280,350};
	struct city city4 = {1,360,350};
	struct city city5 = {1,440,350};
	struct city city6 = {1,520,350};

	base = Physbase();
	iBase = Physbase();

	
	
	
	
	/*Draws the missile silos*/
	plot_bitmap(iBase,32,356,siloLeft_bitmap,32);
	plot_bitmap(iBase,64,356,siloRight_bitmap,32);
	plot_bitmap(iBase,288,356,siloLeft_bitmap,32);
	plot_bitmap(iBase,320,356,siloRight_bitmap,32);
	plot_bitmap(iBase,544,356,siloLeft_bitmap,32);
	plot_bitmap(iBase,576,356,siloRight_bitmap,32);
	
	plot_bitmap(iBase,120,356,cityLeft_bitmap,32);
	plot_bitmap(iBase,176,356,cityLeft_bitmap,32);
	
	plot_bitmap(iBase,232,356,cityLeft_bitmap,32);
	plot_bitmap(iBase,376,356,cityLeft_bitmap,32);
	
	plot_bitmap(iBase,432,356,cityLeft_bitmap,32);
	plot_bitmap(iBase,488,356,cityLeft_bitmap,32);
	


	
	return 0;
}





/* Function to test all the other functions in the code so far */
void test_Driver()
{
	struct city test_City = {1,120,350};
	struct missile_Silo test_Silo = {10,1,300,350};
	struct missile test_Missile = {100,100,10,10,0,0};


	


	/* Working */
	printf("City Health Before Test is: %d\n",test_City.health);
	test_City = destroy_City(test_City);
	printf("City Health is: %d\n",test_City.health);

	printf("Silo Ammo Before Test is: %d\n",test_Silo.ammo);
	test_Silo = update_Ammo(test_Silo);
	printf("Silo Ammo is: %d\n",test_Silo.ammo);

	printf("Silo Before Destroyed is: %d\n",test_Silo.health);
	test_Silo = destroy_Silo(test_Silo);
	printf("Silo After Destroyed is: %d\n",test_Silo.health);

	printf("Testing missile movement position before X:%d Y:%d\n",test_Missile.currentX,test_Missile.currentY);
	test_Missile = missile_Movement(11,11,test_Missile);
	printf("Testing missile movement position after X:%d Y:%d\n",test_Missile.currentX,test_Missile.currentY);

	printf("Testing missile destroyed Before:%d\n",test_Missile.destroyed);
	test_Missile = missile_Destroyed(test_Missile);
	printf("Testing missile destroyed After:%d\n",test_Missile.destroyed);

	printf("Testing enemy missile fired :%d\n",test_Missile.team);
	test_Missile = enemy_Missile_Fired();
	printf("Testing enemy missile fired :%d\n",test_Missile.team);

	printf("Testing friendly missile fired :%d\n",test_Missile.team);
	test_Missile = friendly_Missile_Fired(100,100);
	printf("Testing friendly missile fired :%d\n",test_Missile.team);

	printf("Testing silo choice:%d\n",choose_silo(1));
	printf("Testing silo choice:%d\n",choose_silo(200));
	printf("Testing silo choice:%d\n",choose_silo(500));

	
}





/* Start of the Drawing Functions */
void draw_Line(char *base,unsigned int startX,unsigned int startY, unsigned int endX,unsigned int endY)
{
	int longest,shortest,numerator,i;
	int w = endX - startX;
    int h = endY - startY;
    int dx1 = 0, dy1 = 0, dx2 = 0, dy2 = 0 ;
    
	if (w < 0){
		dx1 = -1;
	}		
	else if (w > 0){
		dx1 = 1 ;
	}
    if (h<0){ 
		dy1 = -1;
	}		
	else if (h>0){
		dy1 = 1;
	}
    if (w<0){
		dx2 = -1;
	}		
	else if (w>0){ 
		dx2 = 1;
	}
	
    longest = abs(w);
    shortest = abs(h);
    
	if (!(longest > shortest)) {
        longest = abs(h) ;
        shortest = abs(w) ;
        if (h < 0){
			dy2 = -1;
		}	
		else if (h > 0){
			dy2 = 1;
		}
        dx2 = 0;            
    }
	
	numerator = longest >> 1;
    
	for (i=0; i <= longest; i++) {
        plot_pixel(base,startX,startY);
        numerator += shortest;
        if (!(numerator<longest)) {
            numerator -= longest;
            startX += dx1;
            startY += dy1;
        } else {
            startX += dx2;
            startY += dy2;
        }
    }

}

/* Plots a Single pixel to the screen */
void plot_pixel(char *base, int x, int y)
{
	if(x >=0 && x < SCREEN_WIDTH && y >=0 && y < SCREEN_HEIGHT)
	{
		*(base + y * 80 + (x >>3)) |= 1 << 7 - (x & 7);
	}
}


void clear_bitmap(long int *base, unsigned int x, unsigned int y, long int map[])
{
	int i,j = 0;
	long int *region = (base + 20 * y) + (x >> 5);
	
	for(i = 0; i < 400; i++)
	{
		for(j = 0; j < 20; j++)
		{
			*region |= *map;
			region += 20;
		}
	}
	
}
void plot_bitmap(long int *base, unsigned int x, unsigned int y, long int map[], int numLines){
	int line = 0;
	long int *region = (base + 20 * y) + (x >> 5);
	
	for (line = 0; line < numLines; line++){
		*region |= *map;
		map++;
		region += 20;
	}
}

/* Start of event handler functions */
/* Checks what key is pressed and returns it */
void keyPress()
{

}


/* Check for mouse movement */
void mouseMovement()
{
 
}
 
 /* Checks for a key click */
void mouseClick()
{
 
}
 
 

/* Destroys city when it is hit */
struct city destroy_City(struct city cityX)
{
	cityX.health = 0;
	create_Explosion(cityX.pX, cityX.pY);
	return cityX;
}

/* Decreases ammo count when missile is fired from a silo */
struct missile_Silo update_Ammo(struct missile_Silo siloX)
{
	if (siloX.ammo > 0){
		siloX.ammo--;
	}
	return siloX;
}

/* Destroys a silo if the silo is hit by a missile */
struct missile_Silo destroy_Silo(struct missile_Silo siloX)
{
	siloX.health = 0;
	create_Explosion(siloX.pX, siloX.pY);
	return siloX;
}


void create_Explosion(unsigned int coordX,unsigned int coordY)
{
	struct explosion newExplosion = {0,1,0,0};
	
	newExplosion.pX = coordX;
	newExplosion.pY = coordY;
	
	while(newExplosion.size < 10)
	{
		newExplosion.size++;
	}
	newExplosion.exists = 0;
}

/* Updates a missiles position, will need to be called from another function which manages 
   the diagonal movements and whether it is a friendly or enemy missile */
struct missile missile_Movement(unsigned int nextX, unsigned int nextY, struct missile Shot)
{
	Shot.currentX = nextX;
	Shot.currentY = nextY;
	return Shot;
}

/* Updates a missile when it reaches the target */
struct missile missile_Destroyed(struct missile Shot)
{
	Shot.destroyed = 1; 
	create_Explosion(Shot.currentX, Shot.currentY);
	return Shot;
}






/* Creates an enemy missile */
struct missile enemy_Missile_Fired()
{
	/* Need some way to randomize where they come out from at the top of the screen
	and their final coordinate */
	struct missile enemyMissile = {0,0,0,0,1,0};
	return enemyMissile;
}

/* Creates a friendly missile, heading towards finalX,finalY */
struct missile friendly_Missile_Fired(unsigned int finalX, unsigned int finalY)
{
	/*Have to figure out which silo, depending on ammo, health, etc. */
	/*Position would depends upon silo chosen*/
	struct missile friendlyMissile = {0,0,0,0,0,0};
	return friendlyMissile;
}

/* Chooses the correct silo for a missile to be fired from depending on where the missile
is heading, 1 = left silo, 2 = middile silo, 3 = right silo */
int choose_silo(unsigned int finalX)
{
	/* Have to find a way to check ammo counts and then spawn the missile from the appropriate
	silo */ 
	int choice = 0;
	if (finalX < 180){
		choice = 1;
	}
	else if (finalX > 180 && finalX < 480){
		choice = 2;
	}
	else{
		choice = 3;
	}
	return choice;
}


	



